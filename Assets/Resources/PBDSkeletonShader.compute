#pragma kernel Skeleton

#include "Quaternion.cginc"
#include "Matrix.cginc"

#define UNITS_AMOUNT 512
#define BONES_AMOUNT 100

struct PBDSkeletonInfo
{
    bool valid;
    int hipsIndex;
    int neckIndex;
};

struct PBDSkeletonBoneTransform
{
    float4x4 Trs;
    int ParentIndex;
};

StructuredBuffer<float3> _positionBuffer;
StructuredBuffer<PBDSkeletonInfo> _skeletonDataBuffer; 
RWStructuredBuffer<PBDSkeletonBoneTransform> _skeletonBoneTransformBuffer;
StructuredBuffer<float4x4> _bindPosesBuffer;

RWStructuredBuffer<float4x4> _boneMatrices;

RWStructuredBuffer<int> _neighboursUnitBuffer; // тут мы будем хранить вторую часть юнита каждой точки. L = POINT_AMOUNT
RWStructuredBuffer<int> _neighboursBuffer; // тут мы будем хранить ближайшего соседа каждой точки (исключая ближайшую из юнита)

int _bonesAmount;
int _rootBoneIndex;

[numthreads(UNITS_AMOUNT,1,1)]
void Skeleton (uint3 id : SV_DispatchThreadID)
{
    if (!_skeletonDataBuffer[id.x].valid) return;
    
    float3 hips = _positionBuffer[_skeletonDataBuffer[id.x].hipsIndex];
    float3 neck = _positionBuffer[_skeletonDataBuffer[id.x].neckIndex];
    float3 p = hips;
    float4 q = qmul(q_look_at(neck - hips, float3(0,1,0)), q_look_at(float3(-1,0,0), float3(0,1,0)));
    _skeletonBoneTransformBuffer[id.x * BONES_AMOUNT + _rootBoneIndex].Trs = compose(p,q, float3(1,1,1));
    
    for (int i = 0; i < _bonesAmount; i++)
    {
        float4x4 boneLocalToWorld = _skeletonBoneTransformBuffer[id.x * BONES_AMOUNT + i].Trs;
        int parentIndex = _skeletonBoneTransformBuffer[id.x * BONES_AMOUNT + i].ParentIndex;
        while (parentIndex != -1)
        {
            boneLocalToWorld = mul(_skeletonBoneTransformBuffer[id.x * BONES_AMOUNT + parentIndex].Trs, boneLocalToWorld);
            parentIndex = _skeletonBoneTransformBuffer[id.x * BONES_AMOUNT + parentIndex].ParentIndex;
        }
        _boneMatrices[id.x * BONES_AMOUNT + i] = mul(boneLocalToWorld, _bindPosesBuffer[i]);
    }   
}
