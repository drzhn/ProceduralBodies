#pragma kernel PBD
#define POINT_AMOUNT 1024

struct PBDPointInfo
{
     bool valid;
     float mass;
     bool collided;
     float radius;
};

struct PBDConnectionInfo
{
    int pointIndex;
    float stiffness;
    float distance;
};

struct PBDBoneInfo
{
    float3 position;
    int parentIndex;
};

float3 ClosestPointOnSegment(float3 p, float3 a, float3 b)
{
    float3 v = b - a;
    float d = dot(p - a, v) / dot(v, v);
    if (d <= 0) return a;
    if (d >= 1) return b;
    return a + d * v;
}

RWStructuredBuffer<PBDPointInfo> _pointsDataBuffer;
RWStructuredBuffer<float3> _positionBuffer;
RWStructuredBuffer<float3> _velocityBuffer;
RWStructuredBuffer<float3> _tempPositionBuffer;
RWStructuredBuffer<PBDConnectionInfo> _connectionDataBuffer;
RWStructuredBuffer<int> _neighboursUnitBuffer; // тут мы будем хранить вторую часть юнита каждой точки. L = POINT_AMOUNT
RWStructuredBuffer<int> _neighboursBuffer; // тут мы будем хранить ближайшего соседа каждой точки (исключая ближайшую из юнита)
RWStructuredBuffer<PBDBoneInfo> _bonesDataBuffer;


int _connectionAmount;
int _bonesAmount;
int _solverSteps;

float _deltaTime;
float _prevDeltaTime;
bool _useGravity;
float _velocityDamping;
float _collisionStiffness;
float _boneStiffness;
 
[numthreads(POINT_AMOUNT,1,1)]
void PBD (uint3 id : SV_DispatchThreadID)
{
    if (_pointsDataBuffer[id.x].valid)
    {
        _velocityBuffer[id.x] = float3(0,0,0);
        if (_prevDeltaTime > 0) // обрабатываем инфу с предыдущего кадра
        { 
            _velocityBuffer[id.x] = (_tempPositionBuffer[id.x] - _positionBuffer[id.x]) / _prevDeltaTime;
        }
        _positionBuffer[id.x] = _tempPositionBuffer[id.x];
        
        
        if (_useGravity) 
        {
            _velocityBuffer[id.x] += _pointsDataBuffer[id.x].mass * 9.8 * _deltaTime * float3(0, -1, 0);
        }
        _velocityBuffer[id.x] *= _velocityDamping;
        _tempPositionBuffer[id.x] = _positionBuffer[id.x] + _deltaTime * _velocityBuffer[id.x];
        
        GroupMemoryBarrierWithGroupSync();
        

        
        for (int solverStep = 0; solverStep < _solverSteps; solverStep ++)
        {
            // Connections
            for (int i = 0; i < _connectionAmount; i++)
            {
                int connectedPointIndex = _connectionDataBuffer[id.x * _connectionAmount + i].pointIndex;
                if (connectedPointIndex != -1)
                {
                    float currentDistance = length(_tempPositionBuffer[connectedPointIndex] - _tempPositionBuffer[id.x]);
                    float initialDistance = _connectionDataBuffer[id.x * _connectionAmount + i].distance;
                    if (currentDistance > _pointsDataBuffer[id.x].radius + _pointsDataBuffer[i].radius)
                    {
                        float stretchingStiffness   = _connectionDataBuffer[id.x * _connectionAmount + i].stiffness;
                        float3 dir = (currentDistance - initialDistance) / currentDistance *
                                      (_tempPositionBuffer[id.x] - _tempPositionBuffer[connectedPointIndex]);
                        float k = _pointsDataBuffer[id.x].mass / (_pointsDataBuffer[id.x].mass + _pointsDataBuffer[connectedPointIndex].mass);
                        _tempPositionBuffer[id.x] -= k * stretchingStiffness * dir;
                    }
                }
            }
            // Collisions with other points
            for (uint j = 0; j < POINT_AMOUNT; j ++)
            {
                if (_pointsDataBuffer[j].valid && j != id.x)
                {
                    float currentDistance = length(_tempPositionBuffer[j] - _tempPositionBuffer[id.x]);
                    float desiredDistance = _pointsDataBuffer[id.x].radius + _pointsDataBuffer[j].radius;
                    if (currentDistance < desiredDistance)
                    {
                        float3 dir = (currentDistance - desiredDistance) / currentDistance * (_tempPositionBuffer[id.x] - _tempPositionBuffer[j]);
                        float k = _pointsDataBuffer[id.x].mass / (_pointsDataBuffer[id.x].mass + _pointsDataBuffer[j].mass);
                        _tempPositionBuffer[id.x] -= k * _collisionStiffness * dir;
                    }
                }
            }
            
            // Bones calculations
            float3 closestPoint = _bonesDataBuffer[0].position;
            for (int k = 1; k < _bonesAmount; k ++)
            {
                float3 p = ClosestPointOnSegment(_tempPositionBuffer[id.x], _bonesDataBuffer[k].position, _bonesDataBuffer[_bonesDataBuffer[k].parentIndex].position);
                if (length(p - _tempPositionBuffer[id.x]) < length(closestPoint - _tempPositionBuffer[id.x]))
                {
                    closestPoint = p;
                }
            }
            
            float3 dir = _tempPositionBuffer[id.x] - closestPoint;
            _tempPositionBuffer[id.x] -= _boneStiffness * dir;
            
            
            GroupMemoryBarrierWithGroupSync();
        }
        

    }
    GroupMemoryBarrierWithGroupSync();
}


